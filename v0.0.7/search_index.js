var documenterSearchIndex = {"docs":
[{"location":"#UsingMerge","page":"Home","title":"UsingMerge","text":"Documentation for UsingMerge.","category":"section"},{"location":"#UsingMerge.UsingMerge","page":"Home","title":"UsingMerge.UsingMerge","text":"This module exports a single macro @usingmerge which differs from using in that it \"merges\" the exported definitions automatically.\n\nThe wish for this started in this thread. At  the time I was very new to Julia  and did not think I could do anything myself about the problem. Two years later, knowing better Julia, I realized I could do something. Here it is.\n\nI introduce the problem with an example.\n\nIn  my Chevie package  I have a  function invariants which computes the invariants of a finite reflection group. However when I use BenchmarkTools  to debug for performance my package, I have the following problem:\n\njulia> G= # some group...\n\njulia> invariants(G)\nWARNING: both Chevie and BenchmarkTools export \"invariants\"; uses of it in module Main must be qualified\nERROR: UndefVarError: invariants not defined\nStacktrace:\n [1] top-level scope at REPL[4]:1\n [2] eval(::Module, ::Any) at ./boot.jl:331\n [3] eval_user_input(::Any, ::REPL.REPLBackend) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/REPL/src/REPL.jl:86\n [4] run_backend(::REPL.REPLBackend) at /home/jmichel/.julia/packages/Revise/kqqw8/src/Revise.jl:1163\n [5] top-level scope at none:0\n\nThis  is  annoying!  I  do  not  want  to  have to qualify every call to my function  invariants just  because I  am timing  my code!  What can I do? Well, first I could just import the methods I am using in BenchmarkTools:\n\njulia> using BenchmarkTools: @btime\n\nActually,  every exported name  from BenchmarkTools, except invariants, does not conflict with my code:\n\njulia> names(BenchmarkTools)\n30-element Array{Symbol,1}:\n Symbol(\"@ballocated\")\n Symbol(\"@belapsed\")\n Symbol(\"@benchmark\")\n Symbol(\"@benchmarkable\")\n Symbol(\"@btime\")\n Symbol(\"@tagged\")\n :BenchmarkGroup\n :BenchmarkTools\n :addgroup!\n :allocs\n :gctime\n :improvements\n :invariants\n :isimprovement\n :isinvariant\n :isregression\n :judge\n :leaves\n :loadparams!\n :mean\n :median\n :memory\n :params\n :ratio\n :regressions\n :rmskew\n :rmskew!\n :trim\n :tune!\n :warmup\n\nso I can do:\n\njulia> using BenchmarkTools: @ballocated, @belapsed, @benchmark, @benchmarkable, @btime, @tagged, BenchmarkGroup, BenchmarkTools, addgroup!, allocs, gctime, improvements, isimprovement, isinvariant, isregression, judge, leaves, loadparams!, mean, median, memory, params, ratio, regressions, rmskew, rmskew!, trim, tune!,\n warmup\n\nStill no conflict. Can I go further and do something even for invariants? Well, I have one method for invariants in my package:\n\ninvariants(a::Group, args...)\n\nwhile BenchmarkTools has four:\n\ninvariants(group::BenchmarkGroup)\ninvariants(x)\ninvariants(f, group::BenchmarkGroup)\ninvariants(f, x)\n\nEven though some of these last methods apply to Any, they do not conflict with  my method  (since at  least one  of the  arguments of  my method, the first,  is qualified with my type Group), so  I can use them also by just defining:\n\ninvariants(group::BenchmarkGroup) = BenchmarkTools.invariants(group)\ninvariants(x) = BenchmarkTools.invariants(x)\ninvariants(f, group::BenchmarkGroup) = BenchmarkTools.invariants(f, group)\ninvariants(f, x) = BenchmarkTools.invariants(f, x)\n\nThe  last thing to do is  make the docstring of BenchmarkTools.invariants accessible to the help of invariants. It happens it has no docstring, but if it had one I must do (this adds to the doc of invariants):\n\n@doc (@doc BenchmarkTools.invariants) invariants\n\nI  call  the  end  result  of  the  above  process  merging  the  package BenchmarkTools  with  my  current  package.  What  I  announce  here is a macro  @usingmerge  which  does  all  the  above automatically. If you do\n\njulia> using UsingMerge\njulia> @usingmerge BenchmarkTools\n\nThe  function determines conflicting method names in the package and merges them as above, and does using of the non-conflicting names.\n\nJust like for using you can usingmerge only some of the names of the package\n\njulia> @usingmerge BenchmarkTools: invariants, ratio\n\nThe macro @usingmerge has two optional arguments\n\njulia> @usingmerge reexport BenchmarkTools\n\nwill   reexport  all  non-conflicting  names  (a  conflicting  name  is  by definition  already present in your environment and will be exported if you did export it).\n\njulia> @usingmerge verbose=true BenchmarkTools\n\nwill  print all conflicts resolved, and verbose=2 will print all executed commands.  \n\nYou will find some more information in the docstring of @usingmerge.\n\nSince  I wrote this function,  I found that I  got the hoped for modularity benefits in my code. For example, I my package Chevie uses the packages\n\nPermGroups Permutations and permutation groups\nCyclotomicNumbers  Sums of complex roots of unity\nLaurentPolynomialss  Univariate Laurent polynomials\nPuiseuxPolynomials    Multivariate Puiseux polynomials\nFinitePosets.jl\nFiniteFields.jl\n\nthat I designed as independent, stand-alone packages which each can be used without  importing anything from my package. To use them together I can now just @usingmerge each of them instead of writing (unpleasant) glue code.\n\nI  do not advocate always  replacing the semantics of  using with that of @usingmerge,  but  I  feel  that  @usingmerge  is a nice tool for using packages  together without having to write glue code (and without having to modify  any of the used packages). The meaning of \"pirating a type\" becomes a   little  bit  wider  in  this  context,  as  you  saw  with  the  method invariants(y)  in BenchmarkTools: it is, I would say, polite, if any of your  methods which has  a possibly conflicting  name uses at  least one of your own types in its signature.\n\nThe  program only merges methods  of functions. If a  conflicting name is a macro,  a struct or  a type, a  message is printed  and the name is not merged.\n\nAny  kind of feedback will be welcome. My implementation is perhaps not the best,  as I kind  of parse the  printed output of  methods. Accessing the internal structure of the returned object would be better but I do not know what's  officially accessible  in there.  If you  have any  comments on the code, functionality or documentation please contact me.\n\n\n\n\n\n","category":"module"},{"location":"#UsingMerge.@usingmerge","page":"Home","title":"UsingMerge.@usingmerge","text":"@usingmerge [reexport] [verbose=true] SomeModule[: symbol1, symbol2...]\n\ndo  using module SomeModule, in addition merging all method definitions (or  using from  SomeModule methods  definitions symbol1, symbol2...) exported  by  SomeModule  with  methods  of  the same name in the current module.\n\nIf  reexport is given all  new names (non-conflicting with  a name in the current  module)  exported  from  SomeModule  are  (re-)exported from the current  module. If a  name is not  new it is  assumed that the decision to export it or not has been taken before.\n\nIf verbose=true conflicting methods are printed. If verbose=2 every executed command is printed before execution. If verbose=3 boths happens.\n\nIf  a name exported  by SomeModule conflicts  with a name  which is not a method a warning is printed and the name is not merged (not imported).\n\nAn example of use:\n\njulia> using UsingMerge\n\njulia> foo(x::Int)=2\nfoo (generic function with 1 method)\n\njulia> module Bar\n       export foo\n       foo(x::Float64)=3\n       end\nMain.Bar\n\njulia> @usingmerge verbose=3 Bar\n# Bar.foo conflicts with Main.foo --- adding methods\nMain.foo(x::Float64) = Bar.foo(x)\n\nOne  could have done @usingmerge Bar:  foo to import/merge foo only. In any  case, note that the equivalent of using  Bar: Bar is done in any case to put the name Bar in scope.\n\n\n\n\n\n","category":"macro"}]
}
